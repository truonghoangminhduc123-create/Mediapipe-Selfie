<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ch·ª•p ·∫¢nh L√†m M·ªù N·ªÅn</title>
    <!-- T·∫£i Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- T·∫£i th∆∞ vi·ªán MediaPipe Selfie Segmentation (ƒê√£ chuy·ªÉn sang phi√™n b·∫£n .js ƒë·ªÉ tr√°nh l·ªói Wasm) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
    <style>
        /* Thi·∫øt l·∫≠p font Inter */
        html { font-family: 'Inter', sans-serif; }
        /* ·∫®n video g·ªëc, ch·ªâ d√πng canvas ƒë·ªÉ hi·ªÉn th·ªã k·∫øt qu·∫£ */
        #videoElement {
            display: none;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-blue': '#1e40af',
                        'secondary-gray': '#f3f4f6',
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div class="w-full max-w-xl bg-white shadow-2xl rounded-xl p-6">
        <h1 class="text-3xl font-bold text-center text-primary-blue mb-6">üì∏ ·ª®ng D·ª•ng L√†m M·ªù N·ªÅn</h1>
        
        <!-- Khu v·ª±c hi·ªÉn th·ªã camera v√† canvas -->
        <div class="relative w-full aspect-[4/3] rounded-lg overflow-hidden mb-6 border-4 border-gray-300 bg-black flex items-center justify-center">
            <!-- Video g·ªëc (b·ªã ·∫©n, d√πng l√†m ngu·ªìn cho MediaPipe) -->
            <video id="videoElement" playsinline autoplay></video>
            
            <!-- Canvas hi·ªÉn th·ªã k·∫øt qu·∫£ ƒë√£ l√†m m·ªù -->
            <canvas id="outputCanvas" class="w-full h-full transform transition-transform duration-300"></canvas>
            
            <!-- Loading indicator -->
            <div id="loadingIndicator" class="absolute inset-0 bg-white/70 backdrop-blur-sm flex flex-col items-center justify-center text-lg font-semibold text-primary-blue z-10">
                <svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-primary-blue" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span>ƒêang t·∫£i MediaPipe...</span>
            </div>

            <!-- Message Box -->
            <div id="messageBox" class="hidden absolute top-4 left-1/2 -translate-x-1/2 bg-red-600 text-white px-4 py-2 rounded-lg shadow-xl text-sm font-medium z-20"></div>

        </div>

        <!-- Thanh ƒëi·ªÅu khi·ªÉn -->
        <div class="flex flex-col space-y-4">
            <div class="grid grid-cols-2 gap-4">
                <button id="toggleCamButton" class="flex items-center justify-center space-x-2 bg-primary-blue text-white py-3 rounded-xl font-semibold shadow-md hover:bg-blue-700 transition duration-150 active:scale-95">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 10l4.55-4.55a.5.5 0 00-.35-.85H5.8a.5.5 0 00-.35.85L10 10m5 0V7m0 3v7m0 0H10m5 0h4.15a.5.5 0 00.35-.85L15 17m0 0L10 12m0 0V9m0 3v5" />
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v-4m0 0V8m0 4h4m-4 0H0" />
                        <path stroke-linecap="round" stroke-linejoin="round" d="M20 8v4m0 0v4m0-4h-4m4 0h4" />
                    </svg>
                    <span>Ch·ªçn Cam</span>
                </button>
                
                <button id="flipButton" class="flex items-center justify-center space-x-2 bg-primary-blue text-white py-3 rounded-xl font-semibold shadow-md hover:bg-blue-700 transition duration-150 active:scale-95">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
                    </svg>
                    <span>ƒê·∫£o Ngang</span>
                </button>
            </div>
            
            <!-- THANH ƒêI·ªÄU CH·ªàNH ƒê·ªò L√ÄM M·ªú M·ªöI -->
            <div class="p-3 bg-gray-50 rounded-lg shadow-inner">
                <label for="blurSlider" class="block text-sm font-medium text-gray-700 mb-2">
                    ƒê·ªô L√†m M·ªù (Blur): <span id="blurValue" class="font-bold text-primary-blue">10px</span>
                </label>
                <input type="range" id="blurSlider" min="0" max="30" value="10" step="1" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
            </div>
            <!-- K·∫æT TH√öC THANH ƒêI·ªÄU CH·ªàNH -->

            <button id="captureButton" class="flex items-center justify-center space-x-2 bg-red-500 text-white py-4 rounded-xl font-bold text-xl shadow-lg hover:bg-red-600 transition duration-150 active:scale-95">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M4 5a2 2 0 00-2 2v8a2 2 0 002 2h12a2 2 0 002-2V7a2 2 0 00-2-2h-1.586a1 1 0 01-.707-.293l-1.121-1.121A.996.996 0 0010 3.379a.996.996 0 00-.707.293L8.293 4.707a1 1 0 01-.707.293H4zm7 5a1 1 0 10-2 0 1 1 0 002 0zm-2 2a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                </svg>
                <span>Ch·ª•p ·∫¢nh</span>
            </button>

            <!-- Khu v·ª±c k·∫øt qu·∫£ ch·ª•p -->
            <div id="captureResult" class="hidden mt-6">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">·∫¢nh ƒê√£ Ch·ª•p:</h2>
                <img id="capturedImage" class="w-full rounded-lg shadow-md border border-gray-200" alt="·∫¢nh ƒë√£ ch·ª•p" />
                <a id="downloadLink" download="anh_lam_mo.png" class="mt-4 block w-full text-center bg-green-500 text-white py-2 rounded-xl font-semibold hover:bg-green-600 transition duration-150 active:scale-95">T·∫£i Xu·ªëng</a>
            </div>
        </div>
    </div>

    <script type="module">
        // Bi·∫øn to√†n c·ª•c
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('outputCanvas');
        const ctx = canvasElement.getContext('2d');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const messageBox = document.getElementById('messageBox');
        
        const toggleCamButton = document.getElementById('toggleCamButton');
        const flipButton = document.getElementById('flipButton');
        const captureButton = document.getElementById('captureButton');

        // NEW: Blur control elements
        const blurSlider = document.getElementById('blurSlider');
        const blurValueDisplay = document.getElementById('blurValue');
        let blurRadius = parseInt(blurSlider.value); // Initialize with slider value (10)

        let cameraDevices = [];
        let currentDeviceIdIndex = 0;
        let isFlipped = false;
        let stream = null;
        let segmentation = null;

        // --- H√†m Utility ---

        // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói
        function showMessage(msg, duration = 3000) {
            messageBox.textContent = msg;
            messageBox.classList.remove('hidden');
            clearTimeout(messageBox.timer);
            messageBox.timer = setTimeout(() => {
                messageBox.classList.add('hidden');
            }, duration);
        }

        // --- Camera & MediaPipe Setup ---

        // L·∫•y danh s√°ch c√°c camera c√≥ s·∫µn
        async function getCameraDevices() {
            try {
                // Y√™u c·∫ßu quy·ªÅn truy c·∫≠p tr∆∞·ªõc ƒë·ªÉ ƒë·∫£m b·∫£o `enumerateDevices` tr·∫£ v·ªÅ t√™n thi·∫øt b·ªã
                await navigator.mediaDevices.getUserMedia({ video: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                cameraDevices = devices.filter(device => device.kind === 'videoinput');
                if (cameraDevices.length === 0) {
                    showMessage('Kh√¥ng t√¨m th·∫•y camera n√†o.');
                    return false;
                }
                return true;
            } catch (error) {
                showMessage(`L·ªói truy c·∫≠p camera: ${error.message}`);
                return false;
            }
        }

        // Kh·ªüi t·∫°o lu·ªìng camera
        async function startCamera(deviceId) {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                video: {
                    deviceId: deviceId ? { exact: deviceId } : undefined,
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                }
            };

            try {
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    // Thi·∫øt l·∫≠p k√≠ch th∆∞·ªõc canvas b·∫±ng k√≠ch th∆∞·ªõc video
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                    // B·∫Øt ƒë·∫ßu x·ª≠ l√Ω MediaPipe sau khi video ƒë√£ t·∫£i
                    if (segmentation) {
                        onCameraReady();
                    }
                };
            } catch (error) {
                showMessage(`Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông camera: ${error.message}.`);
                console.error("L·ªói kh·ªüi ƒë·ªông camera:", error);
            }
        }

        // Chuy·ªÉn ƒë·ªïi camera
        function toggleCamera() {
            if (cameraDevices.length <= 1) {
                showMessage('Ch·ªâ c√≥ m·ªôt camera ƒë∆∞·ª£c t√¨m th·∫•y.');
                return;
            }

            currentDeviceIdIndex = (currentDeviceIdIndex + 1) % cameraDevices.length;
            const newDeviceId = cameraDevices[currentDeviceIdIndex].deviceId;
            startCamera(newDeviceId);
        }

        // ƒê·∫£o ng∆∞·ª£c h√¨nh ·∫£nh camera (l·∫≠t ngang)
        function toggleFlip() {
            isFlipped = !isFlipped;
            if (isFlipped) {
                canvasElement.style.transform = 'scaleX(-1)';
            } else {
                canvasElement.style.transform = 'scaleX(1)';
            }
            showMessage(isFlipped ? 'ƒê√£ b·∫≠t ƒê·∫£o Ngang' : 'ƒê√£ t·∫Øt ƒê·∫£o Ngang');
        }

        // X·ª≠ l√Ω k·∫øt qu·∫£ t·ª´ MediaPipe
        const onResults = (results) => {
            // ·∫®n loading sau khi c√≥ k·∫øt qu·∫£ ƒë·∫ßu ti√™n
            loadingIndicator.classList.add('hidden');

            ctx.save();
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // 1. √Åp d·ª•ng l√†m m·ªù (Blur) cho n·ªÅn
            // K·ªπ thu·∫≠t 1: V·∫Ω to√†n b·ªô h√¨nh ·∫£nh v·ªõi hi·ªáu ·ª©ng m·ªù (Background)
            // S·ª¨ D·ª§NG GI√Å TR·ªä L√ÄM M·ªú ƒê·ªòNG (blurRadius)
            ctx.filter = `blur(${blurRadius}px)`; 
            ctx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            ctx.filter = 'none'; // T·∫Øt filter cho c√°c b∆∞·ªõc ti·∫øp theo

            // 2. T√°i t·∫°o l·ªõp ph·ªß foreground (ng∆∞·ªùi) KH√îNG b·ªã m·ªù
            if (results.segmentationMask) {
                // S·ª≠ d·ª•ng canvas t·∫°m th·ªùi ƒë·ªÉ c√¥ l·∫≠p ƒë·ªëi t∆∞·ª£ng (Foreground Isolation)
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvasElement.width;
                tempCanvas.height = canvasElement.height;
                const tempCtx = tempCanvas.getContext('2d');

                // A. V·∫Ω h√¨nh ·∫£nh KH√îNG M·ªú l√™n canvas t·∫°m
                tempCtx.drawImage(results.image, 0, 0, tempCanvas.width, tempCanvas.height);
                
                // B. D√πng mask ƒë·ªÉ clip h√¨nh ·∫£nh, ch·ªâ gi·ªØ l·∫°i ph·∫ßn ƒë·ªëi t∆∞·ª£ng (destination-in)
                tempCtx.globalCompositeOperation = 'destination-in';
                tempCtx.drawImage(results.segmentationMask, 0, 0, tempCanvas.width, tempCanvas.height);

                // C. V·∫Ω ƒë·ªëi t∆∞·ª£ng ƒë√£ c√¥ l·∫≠p (unblurred) l√™n canvas ch√≠nh
                // Canvas ch√≠nh ƒë√£ c√≥ n·ªÅn m·ªù (Background), n√™n d√πng source-over ƒë·ªÉ v·∫Ω ƒë√® l√™n.
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(tempCanvas, 0, 0);
            }
            
            // N·∫øu c√≥ l·∫≠t ngang b·∫±ng CSS, ta kh√¥ng c·∫ßn l·∫≠t l·∫°i trong canvas.
            ctx.restore();
            
            // Y√™u c·∫ßu ch·∫°y l·∫°i MediaPipe v·ªõi khung h√¨nh ti·∫øp theo
            requestAnimationFrame(sendToMediaPipe);
        };
        
        // V√≤ng l·∫∑p g·ª≠i khung h√¨nh ƒë·∫øn MediaPipe
        async function sendToMediaPipe() {
            if (videoElement.readyState >= 2) { // READY_STATE_HAVE_CURRENT_DATA
                await segmentation.send({ image: videoElement });
            } else {
                // Ch·ªù video s·∫µn s√†ng
                requestAnimationFrame(sendToMediaPipe);
            }
        }

        // Kh·ªüi t·∫°o MediaPipe
        function initializeMediaPipe() {
            segmentation = new SelfieSegmentation({ locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
            }});

            segmentation.setOptions({
                modelSelection: 1, // 0: general, 1: landscape (m∆∞·ª£t h∆°n)
                selfieMode: true,  // Quan tr·ªçng: Th∆∞·ªùng l·∫≠t h√¨nh ·∫£nh ƒë·∫ßu v√†o, nh∆∞ng ch√∫ng ta s·∫Ω x·ª≠ l√Ω l·∫≠t b·∫±ng CSS.
                // Ch√∫ng ta s·∫Ω t·ª± x·ª≠ l√Ω hi·ªáu ·ª©ng blur thay v√¨ d√πng enableSegmentation, nh∆∞ng c·∫ßn segmentation mask.
            });

            segmentation.onResults(onResults);
            
            if (cameraDevices.length > 0) {
                onCameraReady();
            }
        }
        
        // Khi camera v√† MediaPipe ƒë√£ s·∫µn s√†ng
        function onCameraReady() {
            loadingIndicator.classList.add('hidden');
            // B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p x·ª≠ l√Ω h√¨nh ·∫£nh
            sendToMediaPipe();
        }

        // --- Ch·ª©c nƒÉng Ch·ª•p ·∫£nh ---
        function captureImage() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvasElement.width;
            tempCanvas.height = canvasElement.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Copy n·ªôi dung t·ª´ canvas ƒëang hi·ªÉn th·ªã (ƒë√£ c√≥ hi·ªáu ·ª©ng)
            tempCtx.drawImage(canvasElement, 0, 0);

            const imageDataURL = tempCanvas.toDataURL('image/png');
            
            // Hi·ªÉn th·ªã ·∫£nh ƒë√£ ch·ª•p
            const capturedImage = document.getElementById('capturedImage');
            const downloadLink = document.getElementById('downloadLink');
            const captureResult = document.getElementById('captureResult');

            capturedImage.src = imageDataURL;
            downloadLink.href = imageDataURL;
            captureResult.classList.remove('hidden');

            showMessage('·∫¢nh ƒë√£ ƒë∆∞·ª£c ch·ª•p!', 2000);
        }

        // --- Kh·ªüi ƒë·ªông ·ª®ng d·ª•ng ---

        window.onload = async () => {
            const hasDevices = await getCameraDevices();
            initializeMediaPipe();

            if (hasDevices) {
                await startCamera(cameraDevices[currentDeviceIdIndex].deviceId);
            } else {
                 loadingIndicator.querySelector('span').textContent = 'Kh√¥ng c√≥ camera. Vui l√≤ng ki·ªÉm tra quy·ªÅn truy c·∫≠p.';
            }

            // G·∫Øn s·ª± ki·ªán cho thanh tr∆∞·ª£t l√†m m·ªù
            blurSlider.addEventListener('input', (event) => {
                blurRadius = parseInt(event.target.value);
                blurValueDisplay.textContent = `${blurRadius}px`;
                // V√≤ng l·∫∑p requestAnimationFrame s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t hi·ªáu ·ª©ng.
            });

            // G·∫Øn s·ª± ki·ªán cho c√°c n√∫t
            toggleCamButton.addEventListener('click', toggleCamera);
            flipButton.addEventListener('click', toggleFlip);
            captureButton.addEventListener('click', captureImage);
        };

    </script>
</body>
</html>
